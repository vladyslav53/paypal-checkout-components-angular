{"version":3,"sources":["webpack:///checkout.child.loader.js","webpack:///webpack/bootstrap f12f161aedeb42f24936","webpack:///./node_modules/zalgo-promise/src/utils.js","webpack:///./node_modules/zalgo-promise/src/exceptions.js","webpack:///./node_modules/zalgo-promise/src/promise.js","webpack:///./src/loader/index.js","webpack:///./src/lib/namespace.js","webpack:///./src/loader/component.js","webpack:///./src/loader/util.js","webpack:///./src/loader/load.js","webpack:///./src/loader/config.js","webpack:///./src/loader/responder.js"],"names":["e","a","i","window","modules","getPromiseShim","__webpack_require__","Promise","resolver","moduleId","installedModules","exports","module","l","call","resolve","val","reject","err","all","promises","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","./node_modules/zalgo-promise/src/index.js","__webpack_exports__","utils_isPromise","item","Window","constructor","utils_toString","then","dispatchPossiblyUnhandledError","dispatchedErrors","indexOf","push","setTimeout","j","possiblyUnhandledPromiseHandlers","length","exceptions_onPossiblyUnhandledException","handler","cancel","splice","_classCallCheck","instance","Constructor","TypeError","value","toString","global","__zalgopromise__","flushPromises","activeCount","promise_ZalgoPromise","ZalgoPromise","_this","this","resolved","rejected","errorHandled","handlers","result","error","isAsync","res","Error","dispatch","_this2","asyncReject","_this3","dispatching","_handlers$i","onSuccess","onError","promise","flushQueue","undefined","timeout","time","_this4","clearTimeout","toPromise","count","results","prom","hash","keys","map","key","items","method","onPossiblyUnhandledException","context","args","apply","delay","isPromise","flush","promisesToFlush","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","./src/loader/index.js","_extends","assign","target","arguments","source","_interface","xports","namespaces","childnamespaces","namespace","_iterator3","_isArray3","_i3","_extends2","_ref3","childname","childnamespace","_iterator2","_isArray2","_i2","_ref2","./src/loader/interface.js","isCheckoutXComponent","seg","split","config","name_separator","xcomponent","ppcheckout","getVersion","replace","isLatest","version","Boolean","major_version","latest_version","loadScript","url","prop","attrs","callback","container","document","body","head","script","createElement","src","onload","onerror","attr","setAttribute","appendChild","warn","_len","_key","message","join","console","log","parseQuery","queryString","location","search","params","slice","pair","decodeURIComponent","onLoadCheckoutIntegration","integrationResponder","listen","getIntegrationURLs","latest","major","checkoutjs_url","minor","getIntegrationProps","props","script_props","query","env","stage","xchild_global","data-paypal-checkout","data-no-bridge","data-state","loaded","callbacks","shift","respond","urls","Date","now","stack","0"],"mappings":"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","file":"checkout.child.loader.js","sourcesContent":["(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap\n/******/ \tfunction getPromiseShim() {\n/******/ \t                            return __webpack_require__(\"./node_modules/zalgo-promise/src/index.js\")[\"ZalgoPromise\"];\n/******/ \t                        }\n/******/\n/******/ \t                        function Promise(resolver) {\n/******/ \t                            return new (getPromiseShim())(resolver);\n/******/ \t                        }\n/******/\n/******/ \t                        Promise.resolve = function(val)      { return getPromiseShim().resolve(val);  };\n/******/ \t                        Promise.reject  = function(err)      { return getPromiseShim().reject(err);   };\n/******/ \t                        Promise.all     = function(promises) { return getPromiseShim().all(promises); };\n/******/\n/******/ \t                        \n/******/ \t                    \n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"https://www.paypalobjects.com/api/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/zalgo-promise/src/index.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/utils.js\n\nvar utils_toString = {}.toString;\n\nfunction utils_isPromise(item) {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (window.Promise && item instanceof window.Promise) {\n            return true;\n        }\n\n        if (window.Window && item instanceof window.Window) {\n            return false;\n        }\n\n        if (window.constructor && item instanceof window.constructor) {\n            return false;\n        }\n\n        if (utils_toString) {\n            var name = utils_toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/exceptions.js\n\nvar possiblyUnhandledPromiseHandlers = [];\nvar dispatchedErrors = [];\n\nfunction dispatchPossiblyUnhandledError(err) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(function () {\n        throw err;\n    }, 1);\n\n    for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        possiblyUnhandledPromiseHandlers[j](err);\n    }\n}\n\nfunction exceptions_onPossiblyUnhandledException(handler) {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel: function cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/promise.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar global = window.__zalgopromise__ = window.__zalgopromise__ || {\n    flushPromises: [],\n    activeCount: 0\n};\n\nvar promise_ZalgoPromise = function () {\n    function ZalgoPromise(handler) {\n        var _this = this;\n\n        _classCallCheck(this, ZalgoPromise);\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            var _result = void 0;\n            var _error = void 0;\n            var resolved = false;\n            var rejected = false;\n            var isAsync = false;\n\n            try {\n                handler(function (res) {\n                    if (isAsync) {\n                        _this.resolve(res);\n                    } else {\n                        resolved = true;\n                        _result = res;\n                    }\n                }, function (err) {\n                    if (isAsync) {\n                        _this.reject(err);\n                    } else {\n                        rejected = true;\n                        _error = err;\n                    }\n                });\n            } catch (err) {\n                this.reject(err);\n                return;\n            }\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(_result);\n            } else if (rejected) {\n                this.reject(_error);\n            }\n        }\n    }\n\n    ZalgoPromise.prototype.resolve = function resolve(result) {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (utils_isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    };\n\n    ZalgoPromise.prototype.reject = function reject(error) {\n        var _this2 = this;\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (utils_isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            var _err = error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error);\n            error = new Error('Expected reject to be called with Error, got ' + _err);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(function () {\n                if (!_this2.errorHandled) {\n                    dispatchPossiblyUnhandledError(error);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    };\n\n    ZalgoPromise.prototype.asyncReject = function asyncReject(error) {\n        this.errorHandled = true;\n        this.reject(error);\n    };\n\n    ZalgoPromise.prototype.dispatch = function dispatch() {\n        var _this3 = this;\n\n        var dispatching = this.dispatching,\n            resolved = this.resolved,\n            rejected = this.rejected,\n            handlers = this.handlers;\n\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        global.activeCount += 1;\n\n        var _loop = function _loop(i) {\n            var _handlers$i = handlers[i],\n                onSuccess = _handlers$i.onSuccess,\n                onError = _handlers$i.onError,\n                promise = _handlers$i.promise;\n\n\n            var result = void 0;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(_this3.value) : _this3.value;\n                } catch (err) {\n                    promise.reject(err);\n                    return 'continue';\n                }\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(_this3.error);\n                    return 'continue';\n                }\n\n                try {\n                    result = onError(_this3.error);\n                } catch (err) {\n                    promise.reject(err);\n                    return 'continue';\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n            } else if (utils_isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n                } else {\n                    // $FlowFixMe\n                    result.then(function (res) {\n                        promise.resolve(res);\n                    }, function (err) {\n                        promise.reject(err);\n                    });\n                }\n            } else {\n\n                promise.resolve(result);\n            }\n        };\n\n        for (var i = 0; i < handlers.length; i++) {\n            var _ret = _loop(i);\n\n            if (_ret === 'continue') continue;\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        global.activeCount -= 1;\n\n        if (global.activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n    };\n\n    ZalgoPromise.prototype.then = function then(onSuccess, onError) {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        var promise = new ZalgoPromise();\n\n        this.handlers.push({\n            promise: promise,\n            onSuccess: onSuccess,\n            onError: onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    };\n\n    ZalgoPromise.prototype['catch'] = function _catch(onError) {\n        return this.then(undefined, onError);\n    };\n\n    ZalgoPromise.prototype['finally'] = function _finally(handler) {\n        return this.then(function (result) {\n            return ZalgoPromise['try'](handler).then(function () {\n                return result;\n            });\n        }, function (err) {\n            return ZalgoPromise['try'](handler).then(function () {\n                throw err;\n            });\n        });\n    };\n\n    ZalgoPromise.prototype.timeout = function timeout(time, err) {\n        var _this4 = this;\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        var timeout = setTimeout(function () {\n\n            if (_this4.resolved || _this4.rejected) {\n                return;\n            }\n\n            _this4.reject(err || new Error('Promise timed out after ' + time + 'ms'));\n        }, time);\n\n        return this.then(function (result) {\n            clearTimeout(timeout);\n            return result;\n        });\n    };\n\n    ZalgoPromise.prototype.toPromise = function toPromise() {\n        if (!window.Promise) {\n            throw new Error('Could not find window.Promise');\n        }\n        return window.Promise.resolve(this);\n    };\n\n    ZalgoPromise.resolve = function resolve(value) {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (utils_isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise(function (resolve, reject) {\n                return value.then(resolve, reject);\n            });\n        }\n\n        return new ZalgoPromise().resolve(value);\n    };\n\n    ZalgoPromise.reject = function reject(error) {\n        return new ZalgoPromise().reject(error);\n    };\n\n    ZalgoPromise.all = function all(promises) {\n\n        var promise = new ZalgoPromise();\n        var count = promises.length;\n        var results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        var _loop2 = function _loop2(i) {\n            var prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    return 'continue';\n                }\n            } else if (!utils_isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                return 'continue';\n            }\n\n            ZalgoPromise.resolve(prom).then(function (result) {\n                results[i] = result;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, function (err) {\n                promise.reject(err);\n            });\n        };\n\n        for (var i = 0; i < promises.length; i++) {\n            var _ret2 = _loop2(i);\n\n            if (_ret2 === 'continue') continue;\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    };\n\n    ZalgoPromise.hash = function hash(promises) {\n        var result = {};\n\n        return ZalgoPromise.all(Object.keys(promises).map(function (key) {\n            return ZalgoPromise.resolve(promises[key]).then(function (value) {\n                result[key] = value;\n            });\n        })).then(function () {\n            return result;\n        });\n    };\n\n    ZalgoPromise.map = function map(items, method) {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    };\n\n    ZalgoPromise.onPossiblyUnhandledException = function onPossiblyUnhandledException(handler) {\n        return exceptions_onPossiblyUnhandledException(handler);\n    };\n\n    ZalgoPromise['try'] = function _try(method, context, args) {\n\n        var result = void 0;\n\n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            return ZalgoPromise.reject(err);\n        }\n\n        return ZalgoPromise.resolve(result);\n    };\n\n    ZalgoPromise.delay = function delay(_delay) {\n        return new ZalgoPromise(function (resolve) {\n            setTimeout(resolve, _delay);\n        });\n    };\n\n    ZalgoPromise.isPromise = function isPromise(value) {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return utils_isPromise(value);\n    };\n\n    ZalgoPromise.flush = function flush() {\n        var promise = new ZalgoPromise();\n        global.flushPromises.push(promise);\n\n        if (global.activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n\n        return promise;\n    };\n\n    ZalgoPromise.flushQueue = function flushQueue() {\n        var promisesToFlush = global.flushPromises;\n        global.flushPromises = [];\n\n        for (var _iterator = promisesToFlush, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref = _iterator[_i++];\n            } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref = _i.value;\n            }\n\n            var _promise = _ref;\n\n            _promise.resolve();\n        }\n    };\n\n    return ZalgoPromise;\n}();\n\n\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/index.js\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"ZalgoPromise\", function() { return promise_ZalgoPromise; });\n\n\n/***/ }),\n\n/***/ \"./src/loader/index.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/lib/namespace.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction extendNamespace(xports) {\n    var namespaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var childnamespaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n\n    for (var _iterator = namespaces, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n        } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n        }\n\n        var name = _ref;\n\n        var namespace = window[name];\n\n        if (!namespace) {\n            continue;\n        }\n\n        for (var _iterator3 = childnamespaces, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n            var _extends2;\n\n            var _ref3;\n\n            if (_isArray3) {\n                if (_i3 >= _iterator3.length) break;\n                _ref3 = _iterator3[_i3++];\n            } else {\n                _i3 = _iterator3.next();\n                if (_i3.done) break;\n                _ref3 = _i3.value;\n            }\n\n            var childname = _ref3;\n\n            var childnamespace = xports[childname];\n\n            if (namespace[childname]) {\n                childnamespace = _extends({}, namespace[childname], childnamespace);\n            }\n\n            xports = _extends({}, namespace, xports, (_extends2 = {}, _extends2[childname] = childnamespace, _extends2));\n        }\n    }\n\n    for (var _iterator2 = namespaces, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i2++];\n        } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref2 = _i2.value;\n        }\n\n        var _name = _ref2;\n\n        window[_name] = xports;\n    }\n\n    return xports;\n}\n// CONCATENATED MODULE: ./src/loader/index.js\n\n\nvar _interface = __webpack_require__(\"./src/loader/interface.js\"); // eslint-disable-line import/no-commonjs\n\nextendNamespace(_interface, ['paypal']);\n\n/***/ }),\n\n/***/ \"./src/loader/interface.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/loader/config.js\nvar config = {\n    checkoutjs_url: 'https://www.paypalobjects.com/api/checkout{version}.js',\n    major_version: '4',\n    latest_version: 'latest',\n    xcomponent: 'xcomponent',\n    ppcheckout: 'ppcheckout',\n    xchild_global: 'xchild',\n    name_separator: '__',\n\n    script_props: {\n        'data-paypal-checkout': '',\n        'data-no-bridge': '',\n        'data-state': 'ppxo_checkout'\n    }\n};\n// CONCATENATED MODULE: ./src/loader/responder.js\nfunction responder() {\n\n    var callbacks = [];\n    var loaded = false;\n\n    var err = void 0;\n    var res = void 0;\n\n    function flush() {\n        if (loaded) {\n            while (callbacks.length) {\n                callbacks.shift()(err, res);\n            }\n        }\n    }\n\n    function respond(error, result) {\n\n        loaded = true;\n        err = error;\n        res = result;\n\n        flush();\n    }\n\n    function listen(callback) {\n        callbacks.push(callback);\n        flush();\n    }\n\n    return { respond: respond, listen: listen };\n}\n// CONCATENATED MODULE: ./src/loader/component.js\n\n\nfunction isCheckoutXComponent() {\n    if (window.name) {\n        var seg = window.name.split(config.name_separator);\n\n        if (seg[0] === config.xcomponent && seg[1] === config.ppcheckout) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction getVersion() {\n\n    if (!isCheckoutXComponent()) {\n        throw new Error('Can not get version for non-xcomponent');\n    }\n\n    return window.name.split(config.name_separator)[2].replace(/_/g, '.');\n}\n\nfunction isLatest() {\n\n    if (!isCheckoutXComponent()) {\n        return false;\n    }\n\n    var version = getVersion();\n\n    return Boolean(version === config.major_version || version === config.latest_version);\n}\n// CONCATENATED MODULE: ./src/loader/util.js\nfunction loadScript(url, prop, attrs, callback) {\n\n    if (window[prop]) {\n        return callback(null, window[prop]);\n    }\n\n    var container = document.body || document.head;\n\n    if (!container) {\n        return callback(new Error('Can not find container to insert script into'));\n    }\n\n    var script = document.createElement('script');\n\n    script.src = url;\n\n    script.onload = function () {\n        if (!window[prop]) {\n            return callback(new Error('Expected ' + prop + ' to be present on window'));\n        }\n\n        return callback(null, window[prop]);\n    };\n\n    script.onerror = function (err) {\n        return callback(err);\n    };\n\n    for (var _iterator = Object.keys(attrs), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n        } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n        }\n\n        var attr = _ref;\n\n        script.setAttribute(attr, attrs[attr]);\n    }\n\n    container.appendChild(script);\n}\n\nfunction warn() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n\n    var message = args.join(' ');\n\n    if (window.console && window.console.warn) {\n        window.console.warn(message);\n    } else if (window.console && window.console.log) {\n        window.console.log(message);\n    }\n}\n\nfunction parseQuery() {\n    var queryString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n\n    var params = {};\n\n    if (queryString && queryString.indexOf('?') === 0) {\n        queryString = queryString.slice(1);\n    }\n\n    if (!queryString) {\n        return params;\n    }\n\n    if (queryString.indexOf('=') === -1) {\n        throw new Error('Can not parse query string params: ' + queryString);\n    }\n\n    for (var _iterator2 = queryString.split('&'), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i2++];\n        } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref2 = _i2.value;\n        }\n\n        var pair = _ref2;\n\n        pair = pair.split('=');\n\n        if (pair[0] && pair[1]) {\n            params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n    }\n\n    return params;\n}\n// CONCATENATED MODULE: ./src/loader/load.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\n\nvar integrationResponder = responder();\n\nfunction onLoadCheckoutIntegration(callback) {\n    return integrationResponder.listen(callback);\n}\n\nfunction getIntegrationURLs() {\n\n    return {\n        latest: isLatest(),\n        major: config.checkoutjs_url.replace('{version}', ''),\n        minor: config.checkoutjs_url.replace('{version}', '.' + getVersion())\n    };\n}\n\nfunction getIntegrationProps() {\n\n    var props = _extends({}, config.script_props);\n\n    var query = parseQuery();\n\n    if (query.env) {\n        props['data-env'] = query.env;\n    }\n\n    if (query.stage) {\n        props['data-stage'] = query.stage;\n    }\n\n    return props;\n}\n\nfunction loadCheckoutIntegration(callback) {\n\n    if (!isCheckoutXComponent()) {\n        return callback(null, null);\n    }\n\n    var urls = getIntegrationURLs();\n    var props = getIntegrationProps();\n\n    loadScript(urls.latest ? urls.major : urls.minor, config.xchild_global, props, function (err, result) {\n\n        if (err && !urls.latest) {\n            return loadScript(urls.major + '?t=' + Date.now(), config.xchild_global, props, callback);\n        }\n\n        return callback(err, result);\n    });\n}\n\nloadCheckoutIntegration(function (err, result) {\n\n    if (err) {\n        warn('Failed to load checkout.js', err.stack || err.toString());\n    }\n\n    if (err || result) {\n        return integrationResponder.respond(err, result);\n    }\n});\n// CONCATENATED MODULE: ./src/loader/interface.js\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"onLoadCheckoutIntegration\", function() { return onLoadCheckoutIntegration; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"isCheckoutXComponent\", function() { return isCheckoutXComponent; });\n\n\n\n/***/ }),\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"./node_modules/zalgo-promise/src/index.js\");\nmodule.exports = __webpack_require__(\"./src/loader/index.js\");\n\n\n/***/ })\n\n/******/ })));\n\n\n// WEBPACK FOOTER //\n// checkout.child.loader.js"," \tfunction getPromiseShim() {\n \t                            return __webpack_require__(\"./node_modules/zalgo-promise/src/index.js\")[\"ZalgoPromise\"];\n \t                        }\n\n \t                        function Promise(resolver) {\n \t                            return new (getPromiseShim())(resolver);\n \t                        }\n\n \t                        Promise.resolve = function(val)      { return getPromiseShim().resolve(val);  };\n \t                        Promise.reject  = function(err)      { return getPromiseShim().reject(err);   };\n \t                        Promise.all     = function(promises) { return getPromiseShim().all(promises); };\n\n \t                        \n \t                    \n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"https://www.paypalobjects.com/api/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f12f161aedeb42f24936","\nlet toString = ({}).toString;\n\nexport function isPromise(item) {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (window.Promise && item instanceof window.Promise) {\n            return true;\n        }\n\n        if (window.Window && item instanceof window.Window) {\n            return false;\n        }\n\n        if (window.constructor && item instanceof window.constructor) {\n            return false;\n        }\n\n        if (toString) {\n            let name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/utils.js","\nlet possiblyUnhandledPromiseHandlers = [];\nlet dispatchedErrors = [];\n\nexport function dispatchPossiblyUnhandledError(err) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        possiblyUnhandledPromiseHandlers[j](err);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler) {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/exceptions.js","/* @flow */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\n\nlet global = window.__zalgopromise__ = window.__zalgopromise__ || {\n    flushPromises: [],\n    activeCount: 0\n};\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean\n    rejected : boolean\n    errorHandled : boolean\n    value : R\n    error : mixed\n    handlers : Array<{\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    }>\n    dispatching : boolean\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                this.reject(err);\n                return;\n            }\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            let err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${err}`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) {\n        this.errorHandled = true;\n        this.reject(error);\n    }\n\n    dispatch() {\n\n        let { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        global.activeCount += 1;\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            let { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    result.then(res => { promise.resolve(res); },\n                                err => { promise.reject(err);  });\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        global.activeCount -= 1;\n\n        if (global.activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n    }\n\n    then<X : mixed>(onSuccess : void | (result : R) => (ZalgoPromise<X> | X), onError : void | (error : mixed) => (ZalgoPromise<X> | X)) : ZalgoPromise<X> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        let promise : ZalgoPromise<X> = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X : mixed>(onError : (error : mixed) => X | ZalgoPromise<X>) : ZalgoPromise<X> {\n        return this.then(undefined, onError);\n    }\n\n    finally(handler : () => mixed) : ZalgoPromise<R> {\n        return this.then((result) => {\n            return ZalgoPromise.try(handler)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(handler)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        let timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${time}ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    toPromise() : Promise<R> {\n        if (!window.Promise) {\n            throw new Error(`Could not find window.Promise`);\n        }\n        return window.Promise.resolve(this);\n    }\n\n    static resolve<X : mixed>(value : X | ZalgoPromise<X>) : ZalgoPromise<X> {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static all<X: Array<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> {\n\n        let promise = new ZalgoPromise();\n        let count = promises.length;\n        let results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        for (let i = 0; i < promises.length; i++) {\n            let prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            ZalgoPromise.resolve(prom).then(result => {\n                results[i] = result;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                promise.reject(err);\n            });\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<A, O : { [string] : (A | ZalgoPromise<A>) }>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> {\n        let result = {};\n        \n        return ZalgoPromise.all(Object.keys(promises).map(key => {\n            return ZalgoPromise.resolve(promises[key]).then(value => {\n                result[key] = value;\n            });\n        })).then(() => {\n            return result;\n        });\n    }\n\n    static map<T, X>(items : Array<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<Array<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => mixed) : { cancel : () => void } {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X : mixed, C : mixed, A : Array<mixed>>(method : (...args : A) => (ZalgoPromise<X> | X), context : ?C, args : ?A) : ZalgoPromise<X> {\n\n        let result;\n        \n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            return ZalgoPromise.reject(err);\n        }\n\n        return ZalgoPromise.resolve(result);\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        let promise = new ZalgoPromise();\n        global.flushPromises.push(promise);\n\n        if (global.activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n\n        return promise;\n    }\n\n    static flushQueue() {\n        let promisesToFlush = global.flushPromises;\n        global.flushPromises = [];\n\n        for (let promise of promisesToFlush) {\n            promise.resolve();\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/promise.js","/* @flow */\n\nimport { extendNamespace } from '../lib/namespace';\n\nlet _interface = require('./interface'); // eslint-disable-line import/no-commonjs\n\nextendNamespace(_interface, [ 'paypal' ]);\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/index.js","/* @flow */\n\nexport function extendNamespace(xports : Object, namespaces : Array<string> = [], childnamespaces : Array<string> = []) : Object {\n\n    for (let name of namespaces) {\n        let namespace = window[name];\n\n        if (!namespace) {\n            continue;\n        }\n\n        for (let childname of childnamespaces) {\n            let childnamespace = xports[childname];\n\n            if (namespace[childname]) {\n                childnamespace = { ...namespace[childname], ...childnamespace };\n            }\n\n            xports = { ...namespace, ...xports, [ childname ]: childnamespace };\n        }\n    }\n\n    for (let name of namespaces) {\n        window[name] = xports;\n    }\n\n    return xports;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/namespace.js","/* @flow */\n\nimport { config } from './config';\n\nexport function isCheckoutXComponent() : boolean {\n    if (window.name) {\n        let seg = window.name.split(config.name_separator);\n\n        if (seg[0] === config.xcomponent && seg[1] === config.ppcheckout) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function getVersion() : string {\n\n    if (!isCheckoutXComponent()) {\n        throw new Error(`Can not get version for non-xcomponent`);\n    }\n\n    return window.name.split(config.name_separator)[2].replace(/_/g, '.');\n}\n\nexport function isLatest() : boolean {\n\n    if (!isCheckoutXComponent()) {\n        return false;\n    }\n\n    let version = getVersion();\n\n    return Boolean(version === config.major_version || version === config.latest_version);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/component.js","/* @flow */\n\nexport function loadScript(url : string, prop : string, attrs : Object, callback : (err : ?Error, res : ?mixed) => void) : void {\n\n    if (window[prop]) {\n        return callback(null, window[prop]);\n    }\n\n    let container = document.body || document.head;\n\n    if (!container) {\n        return callback(new Error(`Can not find container to insert script into`));\n    }\n\n    let script = document.createElement('script');\n\n    script.src = url;\n\n    script.onload = () => {\n        if (!window[prop]) {\n            return callback(new Error(`Expected ${ prop } to be present on window`));\n        }\n\n        return callback(null, window[prop]);\n    };\n\n    script.onerror = (err : Error) => {\n        return callback(err);\n    };\n\n    for (let attr of Object.keys(attrs)) {\n        script.setAttribute(attr, attrs[attr]);\n    }\n\n    container.appendChild(script);\n}\n\nexport function warn(...args : Array<string>) {\n    let message = args.join(' ');\n\n    if (window.console && window.console.warn) {\n        window.console.warn(message);\n    } else if (window.console && window.console.log) {\n        window.console.log(message);\n    }\n}\n\nexport function parseQuery(queryString : string = window.location.search) : Object {\n\n    let params = {};\n\n    if (queryString && queryString.indexOf('?') === 0) {\n        queryString = queryString.slice(1);\n    }\n\n    if (!queryString) {\n        return params;\n    }\n\n    if (queryString.indexOf('=') === -1) {\n        throw new Error(`Can not parse query string params: ${ queryString }`);\n    }\n\n    for (let pair of queryString.split('&')) {\n        pair = pair.split('=');\n\n        if (pair[0] && pair[1]) {\n            params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n    }\n\n    return params;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/util.js","/* @flow */\n\nimport { config } from './config';\nimport { responder } from './responder';\nimport { isLatest, getVersion, isCheckoutXComponent } from './component';\nimport { loadScript, warn, parseQuery } from './util';\n\nlet integrationResponder = responder();\n\nexport function onLoadCheckoutIntegration(callback : (err : ?Error, result : ?mixed) => void) : void {\n    return integrationResponder.listen(callback);\n}\n\nfunction getIntegrationURLs() : { latest : boolean, major : string, minor : string } {\n\n    return {\n        latest: isLatest(),\n        major:  config.checkoutjs_url.replace('{version}', ''),\n        minor:  config.checkoutjs_url.replace('{version}', `.${ getVersion() }`)\n    };\n}\n\nfunction getIntegrationProps() : Object {\n\n    let props = { ...config.script_props };\n\n    let query = parseQuery();\n\n    if (query.env) {\n        props['data-env'] = query.env;\n    }\n\n    if (query.stage) {\n        props['data-stage'] = query.stage;\n    }\n\n    return props;\n}\n\nfunction loadCheckoutIntegration(callback : (err : ?Error, result : ?mixed) => void) : void {\n\n    if (!isCheckoutXComponent()) {\n        return callback(null, null);\n    }\n\n    let urls = getIntegrationURLs();\n    let props = getIntegrationProps();\n\n    loadScript(urls.latest ? urls.major : urls.minor, config.xchild_global, props, (err, result) => {\n\n        if (err && !urls.latest) {\n            return loadScript(`${ urls.major }?t=${ Date.now() }`, config.xchild_global, props, callback);\n        }\n\n        return callback(err, result);\n    });\n}\n\nloadCheckoutIntegration((err : ?Error, result : ?mixed) : void => {\n\n    if (err) {\n        warn('Failed to load checkout.js', err.stack || err.toString());\n    }\n\n    if (err || result) {\n        return integrationResponder.respond(err, result);\n    }\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/load.js","/* @flow */\n\nexport let config = {\n    checkoutjs_url: 'https://www.paypalobjects.com/api/checkout{version}.js',\n    major_version:  '4',\n    latest_version: 'latest',\n    xcomponent:     'xcomponent',\n    ppcheckout:     'ppcheckout',\n    xchild_global:  'xchild',\n    name_separator: '__',\n\n    script_props: {\n        'data-paypal-checkout': '',\n        'data-no-bridge':       '',\n        'data-state':           'ppxo_checkout'\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/config.js","/* @flow */\n\nexport function responder() : { respond : (error : ?Error, result : ?mixed) => void, listen : (callback : (error : ?Error, result : ?mixed) => void) => void } {\n\n    let callbacks = [];\n    let loaded = false;\n\n    let err;\n    let res;\n\n    function flush() {\n        if (loaded) {\n            while (callbacks.length) {\n                callbacks.shift()(err, res);\n            }\n        }\n    }\n\n    function respond(error : ?Error, result : ?mixed) {\n\n        loaded = true;\n        err    = error;\n        res    = result;\n\n        flush();\n    }\n\n    function listen(callback : (error : ?Error, result : ?mixed) => void) {\n        callbacks.push(callback);\n        flush();\n    }\n\n    return { respond, listen };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/responder.js"],"sourceRoot":""}