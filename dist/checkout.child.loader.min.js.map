{"version":3,"sources":["webpack:///checkout.child.loader.min.js","webpack:///webpack/bootstrap 121e90efa00c2cf71b3d","webpack:///./node_modules/zalgo-promise/src/utils.js","webpack:///./node_modules/zalgo-promise/src/exceptions.js","webpack:///./node_modules/zalgo-promise/src/promise.js","webpack:///./src/loader/index.js","webpack:///./src/lib/namespace.js","webpack:///./src/loader/component.js","webpack:///./src/loader/util.js","webpack:///./src/loader/load.js","webpack:///./src/loader/config.js","webpack:///./src/loader/responder.js"],"names":["e","a","i","window","modules","getPromiseShim","__webpack_require__","Promise","resolver","moduleId","installedModules","exports","module","l","call","resolve","val","reject","err","all","promises","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","./node_modules/zalgo-promise/src/index.js","__webpack_exports__","utils_isPromise","item","Window","constructor","utils_toString","then","dispatchPossiblyUnhandledError","dispatchedErrors","indexOf","push","setTimeout","j","possiblyUnhandledPromiseHandlers","length","exceptions_onPossiblyUnhandledException","handler","cancel","splice","_classCallCheck","instance","Constructor","TypeError","value","toString","global","__zalgopromise__","flushPromises","activeCount","promise_ZalgoPromise","ZalgoPromise","_this","this","resolved","rejected","errorHandled","handlers","result","error","isAsync","res","Error","dispatch","_this2","asyncReject","_this3","dispatching","_handlers$i","onSuccess","onError","promise","flushQueue","undefined","timeout","time","_this4","clearTimeout","toPromise","count","results","prom","hash","keys","map","key","items","method","onPossiblyUnhandledException","context","args","apply","delay","isPromise","flush","promisesToFlush","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","./src/loader/index.js","_extends","assign","target","arguments","source","_interface","xports","namespaces","childnamespaces","namespace","_iterator3","_isArray3","_i3","_extends2","_ref3","childname","childnamespace","_iterator2","_isArray2","_i2","_ref2","./src/loader/interface.js","isCheckoutXComponent","seg","split","config","name_separator","xcomponent","ppcheckout","getVersion","replace","isLatest","version","Boolean","major_version","latest_version","loadScript","url","prop","attrs","callback","container","document","body","head","script","createElement","src","onload","onerror","attr","setAttribute","appendChild","warn","_len","_key","message","join","console","log","parseQuery","queryString","location","search","params","slice","pair","decodeURIComponent","onLoadCheckoutIntegration","integrationResponder","listen","getIntegrationURLs","latest","major","checkoutjs_url","minor","getIntegrationProps","props","script_props","query","env","stage","xchild_global","data-paypal-checkout","data-no-bridge","data-state","loaded","callbacks","shift","respond","urls","Date","now","stack","0"],"mappings":"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","file":"checkout.child.loader.min.js","sourcesContent":["(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap\n/******/ \tfunction getPromiseShim() {\n/******/ \t                            return __webpack_require__(\"./node_modules/zalgo-promise/src/index.js\")[\"ZalgoPromise\"];\n/******/ \t                        }\n/******/\n/******/ \t                        function Promise(resolver) {\n/******/ \t                            return new (getPromiseShim())(resolver);\n/******/ \t                        }\n/******/\n/******/ \t                        Promise.resolve = function(val)      { return getPromiseShim().resolve(val);  };\n/******/ \t                        Promise.reject  = function(err)      { return getPromiseShim().reject(err);   };\n/******/ \t                        Promise.all     = function(promises) { return getPromiseShim().all(promises); };\n/******/\n/******/ \t                        \n/******/ \t                    \n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"https://www.paypalobjects.com/api/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/zalgo-promise/src/index.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/utils.js\n\nvar utils_toString = {}.toString;\n\nfunction utils_isPromise(item) {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (window.Promise && item instanceof window.Promise) {\n            return true;\n        }\n\n        if (window.Window && item instanceof window.Window) {\n            return false;\n        }\n\n        if (window.constructor && item instanceof window.constructor) {\n            return false;\n        }\n\n        if (utils_toString) {\n            var name = utils_toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/exceptions.js\n\nvar possiblyUnhandledPromiseHandlers = [];\nvar dispatchedErrors = [];\n\nfunction dispatchPossiblyUnhandledError(err) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(function () {\n        throw err;\n    }, 1);\n\n    for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        possiblyUnhandledPromiseHandlers[j](err);\n    }\n}\n\nfunction exceptions_onPossiblyUnhandledException(handler) {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel: function cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/promise.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar global = window.__zalgopromise__ = window.__zalgopromise__ || {\n    flushPromises: [],\n    activeCount: 0\n};\n\nvar promise_ZalgoPromise = function () {\n    function ZalgoPromise(handler) {\n        var _this = this;\n\n        _classCallCheck(this, ZalgoPromise);\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            var _result = void 0;\n            var _error = void 0;\n            var resolved = false;\n            var rejected = false;\n            var isAsync = false;\n\n            try {\n                handler(function (res) {\n                    if (isAsync) {\n                        _this.resolve(res);\n                    } else {\n                        resolved = true;\n                        _result = res;\n                    }\n                }, function (err) {\n                    if (isAsync) {\n                        _this.reject(err);\n                    } else {\n                        rejected = true;\n                        _error = err;\n                    }\n                });\n            } catch (err) {\n                this.reject(err);\n                return;\n            }\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(_result);\n            } else if (rejected) {\n                this.reject(_error);\n            }\n        }\n    }\n\n    ZalgoPromise.prototype.resolve = function resolve(result) {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (utils_isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    };\n\n    ZalgoPromise.prototype.reject = function reject(error) {\n        var _this2 = this;\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (utils_isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            var _err = error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error);\n            error = new Error('Expected reject to be called with Error, got ' + _err);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(function () {\n                if (!_this2.errorHandled) {\n                    dispatchPossiblyUnhandledError(error);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    };\n\n    ZalgoPromise.prototype.asyncReject = function asyncReject(error) {\n        this.errorHandled = true;\n        this.reject(error);\n    };\n\n    ZalgoPromise.prototype.dispatch = function dispatch() {\n        var _this3 = this;\n\n        var dispatching = this.dispatching,\n            resolved = this.resolved,\n            rejected = this.rejected,\n            handlers = this.handlers;\n\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        global.activeCount += 1;\n\n        var _loop = function _loop(i) {\n            var _handlers$i = handlers[i],\n                onSuccess = _handlers$i.onSuccess,\n                onError = _handlers$i.onError,\n                promise = _handlers$i.promise;\n\n\n            var result = void 0;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(_this3.value) : _this3.value;\n                } catch (err) {\n                    promise.reject(err);\n                    return 'continue';\n                }\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(_this3.error);\n                    return 'continue';\n                }\n\n                try {\n                    result = onError(_this3.error);\n                } catch (err) {\n                    promise.reject(err);\n                    return 'continue';\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n            } else if (utils_isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n                } else {\n                    // $FlowFixMe\n                    result.then(function (res) {\n                        promise.resolve(res);\n                    }, function (err) {\n                        promise.reject(err);\n                    });\n                }\n            } else {\n\n                promise.resolve(result);\n            }\n        };\n\n        for (var i = 0; i < handlers.length; i++) {\n            var _ret = _loop(i);\n\n            if (_ret === 'continue') continue;\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        global.activeCount -= 1;\n\n        if (global.activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n    };\n\n    ZalgoPromise.prototype.then = function then(onSuccess, onError) {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        var promise = new ZalgoPromise();\n\n        this.handlers.push({\n            promise: promise,\n            onSuccess: onSuccess,\n            onError: onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    };\n\n    ZalgoPromise.prototype['catch'] = function _catch(onError) {\n        return this.then(undefined, onError);\n    };\n\n    ZalgoPromise.prototype['finally'] = function _finally(handler) {\n        return this.then(function (result) {\n            return ZalgoPromise['try'](handler).then(function () {\n                return result;\n            });\n        }, function (err) {\n            return ZalgoPromise['try'](handler).then(function () {\n                throw err;\n            });\n        });\n    };\n\n    ZalgoPromise.prototype.timeout = function timeout(time, err) {\n        var _this4 = this;\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        var timeout = setTimeout(function () {\n\n            if (_this4.resolved || _this4.rejected) {\n                return;\n            }\n\n            _this4.reject(err || new Error('Promise timed out after ' + time + 'ms'));\n        }, time);\n\n        return this.then(function (result) {\n            clearTimeout(timeout);\n            return result;\n        });\n    };\n\n    ZalgoPromise.prototype.toPromise = function toPromise() {\n        if (!window.Promise) {\n            throw new Error('Could not find window.Promise');\n        }\n        return window.Promise.resolve(this);\n    };\n\n    ZalgoPromise.resolve = function resolve(value) {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (utils_isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise(function (resolve, reject) {\n                return value.then(resolve, reject);\n            });\n        }\n\n        return new ZalgoPromise().resolve(value);\n    };\n\n    ZalgoPromise.reject = function reject(error) {\n        return new ZalgoPromise().reject(error);\n    };\n\n    ZalgoPromise.all = function all(promises) {\n\n        var promise = new ZalgoPromise();\n        var count = promises.length;\n        var results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        var _loop2 = function _loop2(i) {\n            var prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    return 'continue';\n                }\n            } else if (!utils_isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                return 'continue';\n            }\n\n            ZalgoPromise.resolve(prom).then(function (result) {\n                results[i] = result;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, function (err) {\n                promise.reject(err);\n            });\n        };\n\n        for (var i = 0; i < promises.length; i++) {\n            var _ret2 = _loop2(i);\n\n            if (_ret2 === 'continue') continue;\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    };\n\n    ZalgoPromise.hash = function hash(promises) {\n        var result = {};\n\n        return ZalgoPromise.all(Object.keys(promises).map(function (key) {\n            return ZalgoPromise.resolve(promises[key]).then(function (value) {\n                result[key] = value;\n            });\n        })).then(function () {\n            return result;\n        });\n    };\n\n    ZalgoPromise.map = function map(items, method) {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    };\n\n    ZalgoPromise.onPossiblyUnhandledException = function onPossiblyUnhandledException(handler) {\n        return exceptions_onPossiblyUnhandledException(handler);\n    };\n\n    ZalgoPromise['try'] = function _try(method, context, args) {\n\n        var result = void 0;\n\n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            return ZalgoPromise.reject(err);\n        }\n\n        return ZalgoPromise.resolve(result);\n    };\n\n    ZalgoPromise.delay = function delay(_delay) {\n        return new ZalgoPromise(function (resolve) {\n            setTimeout(resolve, _delay);\n        });\n    };\n\n    ZalgoPromise.isPromise = function isPromise(value) {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return utils_isPromise(value);\n    };\n\n    ZalgoPromise.flush = function flush() {\n        var promise = new ZalgoPromise();\n        global.flushPromises.push(promise);\n\n        if (global.activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n\n        return promise;\n    };\n\n    ZalgoPromise.flushQueue = function flushQueue() {\n        var promisesToFlush = global.flushPromises;\n        global.flushPromises = [];\n\n        for (var _iterator = promisesToFlush, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref = _iterator[_i++];\n            } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref = _i.value;\n            }\n\n            var _promise = _ref;\n\n            _promise.resolve();\n        }\n    };\n\n    return ZalgoPromise;\n}();\n\n\n// CONCATENATED MODULE: ./node_modules/zalgo-promise/src/index.js\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"ZalgoPromise\", function() { return promise_ZalgoPromise; });\n\n\n/***/ }),\n\n/***/ \"./src/loader/index.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/lib/namespace.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction extendNamespace(xports) {\n    var namespaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var childnamespaces = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n\n    for (var _iterator = namespaces, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n        } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n        }\n\n        var name = _ref;\n\n        var namespace = window[name];\n\n        if (!namespace) {\n            continue;\n        }\n\n        for (var _iterator3 = childnamespaces, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n            var _extends2;\n\n            var _ref3;\n\n            if (_isArray3) {\n                if (_i3 >= _iterator3.length) break;\n                _ref3 = _iterator3[_i3++];\n            } else {\n                _i3 = _iterator3.next();\n                if (_i3.done) break;\n                _ref3 = _i3.value;\n            }\n\n            var childname = _ref3;\n\n            var childnamespace = xports[childname];\n\n            if (namespace[childname]) {\n                childnamespace = _extends({}, namespace[childname], childnamespace);\n            }\n\n            xports = _extends({}, namespace, xports, (_extends2 = {}, _extends2[childname] = childnamespace, _extends2));\n        }\n    }\n\n    for (var _iterator2 = namespaces, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i2++];\n        } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref2 = _i2.value;\n        }\n\n        var _name = _ref2;\n\n        window[_name] = xports;\n    }\n\n    return xports;\n}\n// CONCATENATED MODULE: ./src/loader/index.js\n\n\nvar _interface = __webpack_require__(\"./src/loader/interface.js\"); // eslint-disable-line import/no-commonjs\n\nextendNamespace(_interface, ['paypal']);\n\n/***/ }),\n\n/***/ \"./src/loader/interface.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/loader/config.js\nvar config = {\n    checkoutjs_url: 'https://www.paypalobjects.com/api/checkout{version}.js',\n    major_version: '4',\n    latest_version: 'latest',\n    xcomponent: 'xcomponent',\n    ppcheckout: 'ppcheckout',\n    xchild_global: 'xchild',\n    name_separator: '__',\n\n    script_props: {\n        'data-paypal-checkout': '',\n        'data-no-bridge': '',\n        'data-state': 'ppxo_checkout'\n    }\n};\n// CONCATENATED MODULE: ./src/loader/responder.js\nfunction responder() {\n\n    var callbacks = [];\n    var loaded = false;\n\n    var err = void 0;\n    var res = void 0;\n\n    function flush() {\n        if (loaded) {\n            while (callbacks.length) {\n                callbacks.shift()(err, res);\n            }\n        }\n    }\n\n    function respond(error, result) {\n\n        loaded = true;\n        err = error;\n        res = result;\n\n        flush();\n    }\n\n    function listen(callback) {\n        callbacks.push(callback);\n        flush();\n    }\n\n    return { respond: respond, listen: listen };\n}\n// CONCATENATED MODULE: ./src/loader/component.js\n\n\nfunction isCheckoutXComponent() {\n    if (window.name) {\n        var seg = window.name.split(config.name_separator);\n\n        if (seg[0] === config.xcomponent && seg[1] === config.ppcheckout) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction getVersion() {\n\n    if (!isCheckoutXComponent()) {\n        throw new Error('Can not get version for non-xcomponent');\n    }\n\n    return window.name.split(config.name_separator)[2].replace(/_/g, '.');\n}\n\nfunction isLatest() {\n\n    if (!isCheckoutXComponent()) {\n        return false;\n    }\n\n    var version = getVersion();\n\n    return Boolean(version === config.major_version || version === config.latest_version);\n}\n// CONCATENATED MODULE: ./src/loader/util.js\nfunction loadScript(url, prop, attrs, callback) {\n\n    if (window[prop]) {\n        return callback(null, window[prop]);\n    }\n\n    var container = document.body || document.head;\n\n    if (!container) {\n        return callback(new Error('Can not find container to insert script into'));\n    }\n\n    var script = document.createElement('script');\n\n    script.src = url;\n\n    script.onload = function () {\n        if (!window[prop]) {\n            return callback(new Error('Expected ' + prop + ' to be present on window'));\n        }\n\n        return callback(null, window[prop]);\n    };\n\n    script.onerror = function (err) {\n        return callback(err);\n    };\n\n    for (var _iterator = Object.keys(attrs), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n        } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n        }\n\n        var attr = _ref;\n\n        script.setAttribute(attr, attrs[attr]);\n    }\n\n    container.appendChild(script);\n}\n\nfunction warn() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n    }\n\n    var message = args.join(' ');\n\n    if (window.console && window.console.warn) {\n        window.console.warn(message);\n    } else if (window.console && window.console.log) {\n        window.console.log(message);\n    }\n}\n\nfunction parseQuery() {\n    var queryString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n\n    var params = {};\n\n    if (queryString && queryString.indexOf('?') === 0) {\n        queryString = queryString.slice(1);\n    }\n\n    if (!queryString) {\n        return params;\n    }\n\n    if (queryString.indexOf('=') === -1) {\n        throw new Error('Can not parse query string params: ' + queryString);\n    }\n\n    for (var _iterator2 = queryString.split('&'), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i2++];\n        } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref2 = _i2.value;\n        }\n\n        var pair = _ref2;\n\n        pair = pair.split('=');\n\n        if (pair[0] && pair[1]) {\n            params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n    }\n\n    return params;\n}\n// CONCATENATED MODULE: ./src/loader/load.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\n\nvar integrationResponder = responder();\n\nfunction onLoadCheckoutIntegration(callback) {\n    return integrationResponder.listen(callback);\n}\n\nfunction getIntegrationURLs() {\n\n    return {\n        latest: isLatest(),\n        major: config.checkoutjs_url.replace('{version}', ''),\n        minor: config.checkoutjs_url.replace('{version}', '.' + getVersion())\n    };\n}\n\nfunction getIntegrationProps() {\n\n    var props = _extends({}, config.script_props);\n\n    var query = parseQuery();\n\n    if (query.env) {\n        props['data-env'] = query.env;\n    }\n\n    if (query.stage) {\n        props['data-stage'] = query.stage;\n    }\n\n    return props;\n}\n\nfunction loadCheckoutIntegration(callback) {\n\n    if (!isCheckoutXComponent()) {\n        return callback(null, null);\n    }\n\n    var urls = getIntegrationURLs();\n    var props = getIntegrationProps();\n\n    loadScript(urls.latest ? urls.major : urls.minor, config.xchild_global, props, function (err, result) {\n\n        if (err && !urls.latest) {\n            return loadScript(urls.major + '?t=' + Date.now(), config.xchild_global, props, callback);\n        }\n\n        return callback(err, result);\n    });\n}\n\nloadCheckoutIntegration(function (err, result) {\n\n    if (err) {\n        warn('Failed to load checkout.js', err.stack || err.toString());\n    }\n\n    if (err || result) {\n        return integrationResponder.respond(err, result);\n    }\n});\n// CONCATENATED MODULE: ./src/loader/interface.js\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"onLoadCheckoutIntegration\", function() { return onLoadCheckoutIntegration; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"isCheckoutXComponent\", function() { return isCheckoutXComponent; });\n\n\n\n/***/ }),\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"./node_modules/zalgo-promise/src/index.js\");\nmodule.exports = __webpack_require__(\"./src/loader/index.js\");\n\n\n/***/ })\n\n/******/ })));\n\n\n// WEBPACK FOOTER //\n// checkout.child.loader.min.js"," \tfunction getPromiseShim() {\n \t                            return __webpack_require__(\"./node_modules/zalgo-promise/src/index.js\")[\"ZalgoPromise\"];\n \t                        }\n\n \t                        function Promise(resolver) {\n \t                            return new (getPromiseShim())(resolver);\n \t                        }\n\n \t                        Promise.resolve = function(val)      { return getPromiseShim().resolve(val);  };\n \t                        Promise.reject  = function(err)      { return getPromiseShim().reject(err);   };\n \t                        Promise.all     = function(promises) { return getPromiseShim().all(promises); };\n\n \t                        \n \t                    \n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"https://www.paypalobjects.com/api/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 121e90efa00c2cf71b3d","\nlet toString = ({}).toString;\n\nexport function isPromise(item) {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (window.Promise && item instanceof window.Promise) {\n            return true;\n        }\n\n        if (window.Window && item instanceof window.Window) {\n            return false;\n        }\n\n        if (window.constructor && item instanceof window.constructor) {\n            return false;\n        }\n\n        if (toString) {\n            let name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/utils.js","\nlet possiblyUnhandledPromiseHandlers = [];\nlet dispatchedErrors = [];\n\nexport function dispatchPossiblyUnhandledError(err) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        possiblyUnhandledPromiseHandlers[j](err);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler) {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/exceptions.js","/* @flow */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\n\nlet global = window.__zalgopromise__ = window.__zalgopromise__ || {\n    flushPromises: [],\n    activeCount: 0\n};\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean\n    rejected : boolean\n    errorHandled : boolean\n    value : R\n    error : mixed\n    handlers : Array<{\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    }>\n    dispatching : boolean\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                this.reject(err);\n                return;\n            }\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            let err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${err}`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) {\n        this.errorHandled = true;\n        this.reject(error);\n    }\n\n    dispatch() {\n\n        let { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        global.activeCount += 1;\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            let { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    result.then(res => { promise.resolve(res); },\n                                err => { promise.reject(err);  });\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        global.activeCount -= 1;\n\n        if (global.activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n    }\n\n    then<X : mixed>(onSuccess : void | (result : R) => (ZalgoPromise<X> | X), onError : void | (error : mixed) => (ZalgoPromise<X> | X)) : ZalgoPromise<X> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        let promise : ZalgoPromise<X> = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X : mixed>(onError : (error : mixed) => X | ZalgoPromise<X>) : ZalgoPromise<X> {\n        return this.then(undefined, onError);\n    }\n\n    finally(handler : () => mixed) : ZalgoPromise<R> {\n        return this.then((result) => {\n            return ZalgoPromise.try(handler)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(handler)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        let timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${time}ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    toPromise() : Promise<R> {\n        if (!window.Promise) {\n            throw new Error(`Could not find window.Promise`);\n        }\n        return window.Promise.resolve(this);\n    }\n\n    static resolve<X : mixed>(value : X | ZalgoPromise<X>) : ZalgoPromise<X> {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static all<X: Array<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> {\n\n        let promise = new ZalgoPromise();\n        let count = promises.length;\n        let results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        for (let i = 0; i < promises.length; i++) {\n            let prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            ZalgoPromise.resolve(prom).then(result => {\n                results[i] = result;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                promise.reject(err);\n            });\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<A, O : { [string] : (A | ZalgoPromise<A>) }>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> {\n        let result = {};\n        \n        return ZalgoPromise.all(Object.keys(promises).map(key => {\n            return ZalgoPromise.resolve(promises[key]).then(value => {\n                result[key] = value;\n            });\n        })).then(() => {\n            return result;\n        });\n    }\n\n    static map<T, X>(items : Array<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<Array<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => mixed) : { cancel : () => void } {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X : mixed, C : mixed, A : Array<mixed>>(method : (...args : A) => (ZalgoPromise<X> | X), context : ?C, args : ?A) : ZalgoPromise<X> {\n\n        let result;\n        \n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            return ZalgoPromise.reject(err);\n        }\n\n        return ZalgoPromise.resolve(result);\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        let promise = new ZalgoPromise();\n        global.flushPromises.push(promise);\n\n        if (global.activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n\n        return promise;\n    }\n\n    static flushQueue() {\n        let promisesToFlush = global.flushPromises;\n        global.flushPromises = [];\n\n        for (let promise of promisesToFlush) {\n            promise.resolve();\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/promise.js","/* @flow */\n\nimport { extendNamespace } from '../lib/namespace';\n\nlet _interface = require('./interface'); // eslint-disable-line import/no-commonjs\n\nextendNamespace(_interface, [ 'paypal' ]);\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/index.js","/* @flow */\n\nexport function extendNamespace(xports : Object, namespaces : Array<string> = [], childnamespaces : Array<string> = []) : Object {\n\n    for (let name of namespaces) {\n        let namespace = window[name];\n\n        if (!namespace) {\n            continue;\n        }\n\n        for (let childname of childnamespaces) {\n            let childnamespace = xports[childname];\n\n            if (namespace[childname]) {\n                childnamespace = { ...namespace[childname], ...childnamespace };\n            }\n\n            xports = { ...namespace, ...xports, [ childname ]: childnamespace };\n        }\n    }\n\n    for (let name of namespaces) {\n        window[name] = xports;\n    }\n\n    return xports;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/namespace.js","/* @flow */\n\nimport { config } from './config';\n\nexport function isCheckoutXComponent() : boolean {\n    if (window.name) {\n        let seg = window.name.split(config.name_separator);\n\n        if (seg[0] === config.xcomponent && seg[1] === config.ppcheckout) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function getVersion() : string {\n\n    if (!isCheckoutXComponent()) {\n        throw new Error(`Can not get version for non-xcomponent`);\n    }\n\n    return window.name.split(config.name_separator)[2].replace(/_/g, '.');\n}\n\nexport function isLatest() : boolean {\n\n    if (!isCheckoutXComponent()) {\n        return false;\n    }\n\n    let version = getVersion();\n\n    return Boolean(version === config.major_version || version === config.latest_version);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/component.js","/* @flow */\n\nexport function loadScript(url : string, prop : string, attrs : Object, callback : (err : ?Error, res : ?mixed) => void) : void {\n\n    if (window[prop]) {\n        return callback(null, window[prop]);\n    }\n\n    let container = document.body || document.head;\n\n    if (!container) {\n        return callback(new Error(`Can not find container to insert script into`));\n    }\n\n    let script = document.createElement('script');\n\n    script.src = url;\n\n    script.onload = () => {\n        if (!window[prop]) {\n            return callback(new Error(`Expected ${ prop } to be present on window`));\n        }\n\n        return callback(null, window[prop]);\n    };\n\n    script.onerror = (err : Error) => {\n        return callback(err);\n    };\n\n    for (let attr of Object.keys(attrs)) {\n        script.setAttribute(attr, attrs[attr]);\n    }\n\n    container.appendChild(script);\n}\n\nexport function warn(...args : Array<string>) {\n    let message = args.join(' ');\n\n    if (window.console && window.console.warn) {\n        window.console.warn(message);\n    } else if (window.console && window.console.log) {\n        window.console.log(message);\n    }\n}\n\nexport function parseQuery(queryString : string = window.location.search) : Object {\n\n    let params = {};\n\n    if (queryString && queryString.indexOf('?') === 0) {\n        queryString = queryString.slice(1);\n    }\n\n    if (!queryString) {\n        return params;\n    }\n\n    if (queryString.indexOf('=') === -1) {\n        throw new Error(`Can not parse query string params: ${ queryString }`);\n    }\n\n    for (let pair of queryString.split('&')) {\n        pair = pair.split('=');\n\n        if (pair[0] && pair[1]) {\n            params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n    }\n\n    return params;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/util.js","/* @flow */\n\nimport { config } from './config';\nimport { responder } from './responder';\nimport { isLatest, getVersion, isCheckoutXComponent } from './component';\nimport { loadScript, warn, parseQuery } from './util';\n\nlet integrationResponder = responder();\n\nexport function onLoadCheckoutIntegration(callback : (err : ?Error, result : ?mixed) => void) : void {\n    return integrationResponder.listen(callback);\n}\n\nfunction getIntegrationURLs() : { latest : boolean, major : string, minor : string } {\n\n    return {\n        latest: isLatest(),\n        major:  config.checkoutjs_url.replace('{version}', ''),\n        minor:  config.checkoutjs_url.replace('{version}', `.${ getVersion() }`)\n    };\n}\n\nfunction getIntegrationProps() : Object {\n\n    let props = { ...config.script_props };\n\n    let query = parseQuery();\n\n    if (query.env) {\n        props['data-env'] = query.env;\n    }\n\n    if (query.stage) {\n        props['data-stage'] = query.stage;\n    }\n\n    return props;\n}\n\nfunction loadCheckoutIntegration(callback : (err : ?Error, result : ?mixed) => void) : void {\n\n    if (!isCheckoutXComponent()) {\n        return callback(null, null);\n    }\n\n    let urls = getIntegrationURLs();\n    let props = getIntegrationProps();\n\n    loadScript(urls.latest ? urls.major : urls.minor, config.xchild_global, props, (err, result) => {\n\n        if (err && !urls.latest) {\n            return loadScript(`${ urls.major }?t=${ Date.now() }`, config.xchild_global, props, callback);\n        }\n\n        return callback(err, result);\n    });\n}\n\nloadCheckoutIntegration((err : ?Error, result : ?mixed) : void => {\n\n    if (err) {\n        warn('Failed to load checkout.js', err.stack || err.toString());\n    }\n\n    if (err || result) {\n        return integrationResponder.respond(err, result);\n    }\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/load.js","/* @flow */\n\nexport let config = {\n    checkoutjs_url: 'https://www.paypalobjects.com/api/checkout{version}.js',\n    major_version:  '4',\n    latest_version: 'latest',\n    xcomponent:     'xcomponent',\n    ppcheckout:     'ppcheckout',\n    xchild_global:  'xchild',\n    name_separator: '__',\n\n    script_props: {\n        'data-paypal-checkout': '',\n        'data-no-bridge':       '',\n        'data-state':           'ppxo_checkout'\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/config.js","/* @flow */\n\nexport function responder() : { respond : (error : ?Error, result : ?mixed) => void, listen : (callback : (error : ?Error, result : ?mixed) => void) => void } {\n\n    let callbacks = [];\n    let loaded = false;\n\n    let err;\n    let res;\n\n    function flush() {\n        if (loaded) {\n            while (callbacks.length) {\n                callbacks.shift()(err, res);\n            }\n        }\n    }\n\n    function respond(error : ?Error, result : ?mixed) {\n\n        loaded = true;\n        err    = error;\n        res    = result;\n\n        flush();\n    }\n\n    function listen(callback : (error : ?Error, result : ?mixed) => void) {\n        callbacks.push(callback);\n        flush();\n    }\n\n    return { respond, listen };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/loader/responder.js"],"sourceRoot":""}